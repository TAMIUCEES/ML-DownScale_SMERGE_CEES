# -*- coding: utf-8 -*-
"""auto_multipoint_extractor.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uyJCye6AGsN7KO997T4A7MiJjNSetCJI

#Introduction
**Auto_mutltipoint_extractor** program allows the user to extract multiple points automatically. The program extracts cell values and multipoints, at locations specified in a point feature class from one or more rasters and records the value to the attribute table of the point feature class, by creating multipoints. Consequently, multi-points are useful for geoprocessing tasks where the user needs to work with coordinates. This tool modifies the input point features and the cell values will be extracted from all input rasters at each location.

---
The following libraries allow the program to run.
>* **arcpy** - Allows to run all train and test scripts in an interactive environment.
* **env** - Accesses and uses the arcpy library to define variables in the env module.
* **re** - regular expression or re-uses a set of strings or searches for a certain pattern.
* **Pandas** -  Used to model, analysis, and manipulate data sets
* **arcpy.sa import *** - from the arcpy.sa module the user can use the *arcpy.sa import* to use spatial analyst.
* **os** - Allows the directory service to provides the ability to create and remove directory folders, gather data, change and find the current directory, and provide a means for users and the operating system to interact with each other
"""

# Libraries
import arcpy
from arcpy import env
import re
import pandas as pd
from arcpy.sa import *
import os

"""- If the *input_raster* exists, then the values are extracted from the input raster and are transferred to the shapefile which creates a new raster file due to the *ExtractMultiValuesToPoints*."""

def raster_points(input_raster,output_raster,shp_file):
  # Read the input and check rasters
  in_raster = Raster(input_raster)
  ExtractMultiValuesToPoints(shp_file,[[in_raster,ouput_raster]],'NONE')
  #arcpy.sa.ExtractValuesToPoints(thrity_points, in_raster,thirty_points,'NONE')

# Define the parent folder and the geodatabase name
parent_folder = os.getcwd()
geodatabase_name = "example2.gdb"

"""- The **geodatabase_path** will be created. If the file exists, then the file will be printed for the user's reference. Conversely, if the file does not exist, a new one will be created at the specified path.

-  The created workspace allows for variables to be placed on the *geodatabase_path*. The *geodatabase_path* enables geoprocessing operations to utilize ArcPy as the default workspace, thereby facilitating the processing of variables.
- The parallel environment processing will be set to *0*, where spatial analysis can be utilized. Multidimensional variables will not be employed and will be set to *False*. The calculated results can be overwritten on an existing output file.
"""

# Create the file geodatabase
geodatabase_path = os.path.join(parent_folder,geodatabase_name)
if os.path.exists(geodatabase_path):
  print(geodatabase_path)
else:
  arcpy.CreateFileGDB_management(parent_folder,geodatabase_name)

# Set the geodatabase as the workspace
arcpy.env.workspace = geodatabase_path

# Set up the environment
arcpy.env.parallelProcessingFactor = 0
arcpy.CheckOutExtension("Spatial")
arcpy.env.matchMultidimensionalVariable = False
arcpy.env.overwriteOutput = True

"""- Enter the product, input directory, and file path with name.

  - An example of the data product would be the following:
>*Enter the name of the data product:* **PPT**

  - An example of the input directory would be the following:
  >*Enter the input directory:* **E:\\share\\BIgRun\\Prism_PPT**

  - An example of the full file path, including the grid shape file, would be the following:
  >*Enter the full file path and name of the grid shape file:* **E:\\share\\BIgRun\\Grids\\Grid_30.shp**

    - If the file does not exist then user will have to try again until told otherwise.
"""

# Set data product name
product = input("Enter the name of the data product: ")

# Set the input directory
input_dir = input("Enter the input directory: ")

# Set the file path and name of the grid shape file
grid_shape_file = input("Enter the full file path and name of the grid shape file: ")
while not os.path.exists(grid_shape_file):
  print('The shapefile was not found')
  co = input("Please try again: ")

"""- The user is prompted to provide the information about the file they intend to work on. The file path and the name of the template point shapefile are combined to create a file.

- An example would be the following:
  - Gathering data for point shape file:
    > *Enter the full path of the template point shape file:* **E:\\\share\ArcGIS Projects\\\US_Soils\\\US_Soils.gdb**

    > *Enter the name of the template point shape file:* **Grid_30_Prime_label**

    > *Enter the name of the point shape file:* **PPT_30_Points.shp**

    > *Enter 'Y' if you are adding to an existing point shape file. If the user is creating or overwriting a new point file enter 'N':* **Y**

 - The template for the point shape file is then combined with the data provided using the file path and name.

  - Output from the given data:
    > *Point shape name:* **PPT_30_Points.shp**

    > *File used:* **C:\\\Users\\\user_name\\\Documents\\\example2.gdb\\\PPT_30_Points.shp**


"""

# Data needed for point shape file
temp_point_shape_path = input("Enter the full file path of the template point shape file: ")
temp_point_shape_name = input("Enter the name of the template point shape file: ")
temp_point_shape_file = os.path.join(temp_point_shape_path,temp_point_shape_name)

point_shape_name = input("Enter the name of the point shape file: ")
point_check = input("Enter 'Y' if you are adding to an existing point shape file. If you are creating or overwriting a new point file enter 'N': ")

"""- When the user inputs 'Y' to add to an existing point shape file, the point shape name is displayed.
 - Subsequently, a file is created by combining the template point shapefile and the name of the template point shapefile. Conversely, if the user enters 'N', the variable *temp_point_shape_file* is utilized to create a file using *geodatabase_path* and *point_shape_name*.
"""

print(point_shape_name)

while not point_check != 'Y' and point_check != 'N':
  point_shape_file = input("Please try again: ")

if point_check =='Y':
 while not os.path.isfile(point_shape_file):
 print('The shapefile was not found, should be in the same directory as the .py script')
 point_shape_file = input("Please try again: ")

thirty_points = temp_point_shape_file
gb_thirty_points = os.path.join(geodatabase_path, point_shape_name)
print(gb_thirty_points)

if point_check == 'N':
  arcpy.conversion.FeatureClassToFeatureClass(thirty_points, geodatabase_path, point_shape_name)

"""> **Note:**
  - The user must create a text file name "*dates.txt* ". This file will store the dates that will be used for the application.

- The data from the file **"dates.txt"** will be read and parsed into a list of dates.

  Subsequently, the user will be prompted to input two values: monthly lag and offset. These values will be set to integers.

  Additionally, the user will specify the index from which the list of dates should be sliced.
  
  The code will then update the list by extracting the elements from the specified starting index to the end of the list.

- An example of the monthly lag number would be the following:
  > *Enter the number monthly lag:* **0**
  
- An example of the day offset would be the following:
  > *Enter the day offset:* **0**

- An example if the user wishes to begin on a separate date would be the following:
  > *If you need to start on a different date, enter its index. If not, enter 1:* **1**
"""

# Read the list of dates
while not os.path.exists("dates.txt"):
  print('The date list text was not found, should be in the same directory as the .py script. ')
  n = input("Press enter to try again: ")
text_file = open("dates.txt")
date = text_file.read().split(',')

lag = input("Enter the number monthly lag: ")
lag = int(lag)

offset = input("Enter the day offset: ")
offset = int(offset)

start = input("If you need to start on a different date, enter its index. If not, enter 1: ")
start = int(start) - 1

date = date[start:]

"""- The file extension is responsible for indicating the file's layout and structure. Similarly, the filename separator serves as a component of the file's title, enhancing its readability for users. Furthermore, the user is prompted to specify the position of the date and the specific dates that should be processed.

 - An example of the file extension would be the following:
  > *Enter the file extension:* **.bil**

 - An example of the filename separator would be the following:
  > *Enter the filename separator:* **_**

 - An example of the position of the date would be the following:
  > *Enter the position of the date within the filenames, starting at index 0 (i.e., ALB_2000123 position is 1):* **4**

 - An example of the year not needed would be the following:
  > *Enter the year you wish to process (to process all, leave blank and press enter):*
  
 - An example of the date formatting would be the following:
  > *If the file uses %Y%j, type 'A'. Else if the file uses %Y%m%d, type 'B' :* **B**
"""

# File type
fytpe = input("Enter the file extension: ")

# Filename separator
sep = input("Enter the filename separator: ")

# Date Position
d_pos = input('Enter the position of the date within the filenames, starting at index 0 (example ALB_2000123 position is 1): ')
d_pos = int(d_pos)

# Year batch
yer = input("Enter the year you wish to process (to process all leave blank and press enter): ")

# Date Formatting
d_f = input("If the file uses %Y%j, type 'A'. Else if the file uses %Y%m%d, type 'B': ")
while d_f != 'A' and d_f != 'B':
  d = input("Input ERROR. If the file uses %Y%j, type 'A'. Else if the file uses %Y%m%d, type 'B': ")

if d_f == 'A':
  d_format = %Y%j
if d_f == 'B':
  d_format = %Y%m%d

"""- The **fdir** command is utilized to compile a catalog of directories within a designated directory.

  Subsequently, an empty list is established under the **ref_dir** variable.
   
  The program proceeds to ascertain whether the current file, denoted as **fd**, concludes with the specified file extension, **ftype**.
  
  If the condition is met, the file with the specified extension is appended to the **ref_dir** list.
"""

# Creates list
fdir = os.listdir(input_dir)
ref_dir = []
for fd in fdir:
  if fd.endswith(ftype):
    ref_dir.append(fd)
i = start

"""- The code enters a loop that iterates through each date in the **date** list. For each date in the list, the **j** variable is initialized to *False*.
  - The program first converts a date formatted as '*%m/%d/%Y* ' into a datetime object, then adds a specified number of months to the date.

  - The variable **date_n** provides the year, which is extracted from it. **u_date_n** is created by adding the specified number of days to **date_n**. **l_date_n** is created  by subtracting the specified number of days from **date_n**.

- The loop runs through every file in the directory  **ref_dir**. For each file in the directory, the variable **j** checks if it is set to **True**. If it is, the loop is exited immediately by executing the *break* statement. and the following code.
  - The filenames that match the pattern **f** are split using the separator specified in the **sep** variable, and the resulting parts are stored in **file_p**. Subsequently, the regular expression "\D" is used to replace any non-digit characters in the **d_pos** element of **file_p** with a " \\ ". Finally, each element in **file_p** is converted to a datetime object using the format specified in **d_format**, and the resulting datetime objects are stored in **date_p**.
  - Based on the input provided for formatting the date:
    - If '*A* ', then:
     - The day of the year is extracted from **date_n** and stored in the variable **doy**.
      - The year and day of the year of **u_date_n** are concatenated and saved under **u_date_c**.
      - The year and day of the year of **l_date_n** are concatenated and set to the variable **l_date_c**.
    - If '*B* ', then:
      - The year, month, and day of **u_date_n** are concatenated and stored in **u_date_c**.
      - The year, month, and day of **l_date_n** are concatenated and saved under **l_date_c**.
    - If **date_p.year == year** (if the year of *date_p* variable matches the *year* variable), then:
     - The **input_raster** variable is assigned the full path of the **input_dir** and the filename **f**.
     - The variable **data_name** is assigned the concatenation of the variables, **product** and **i**, separated by an underscore "_".
     - The variable **file_p** will be printed. The **data_name** and the string of **date_n** will be concatenated with a space in between and the result will be printed.
     - The value of **data_name** will be assigned to the variable **output_raster**.
     - The **raster_points** function takes three arguments: **input_raster**, **output_raster**, and **gb_thirty_points**. The function creates a new raster file called **output_raster** by using the data from an existing raster file, **input_raster**, and the specified points in **gb_thirty_points**.
     - The variable **j** is assigned the value *True*, which signifies the end of the program execution for the specified date.
  - Finally, variable **i** is incremented by **1**, which triggers the program to run again with the next set of data.
"""

# Sets format for date
for d in date:
  j = False
  # Converts current date to datetime and adds specified number of months
  date_n = pd.to_datetime(d, format = "%m%d%Y") + pd.DateOffset(months = lag)
  # Extracts the year from date_n
  year = date_n.year
  # Adds specified days to date_n
  u_date_n = date_n + pd.DateOffset(days=offset)
  # Subtracts specified days from date_n
  l_date_n = date_n - pd.DateOffset(days=offset)
  for f in ref dir:
    if j == True:
      break
    # Splits f using the separator (sep)
    file_p = f.split(sep)
    # Replaces non-digit charac. with a "\"
    file_p = re.sub("D","\\",file_p[d_pos])
    # Converts to datetime
    date_p = pd.to_datetime(file_p, formate = d_format)

    if d_f == 'A':
      # Extracts day of year from date_n and stores in doy
      doy = date_n.timetuple().tm_yday
      # Concatenates the year with day of year of u_date_n
      u_date_c = str(u_date_n.year) + str(u_date_n.timetupe().tm_yday).zfill(3)
      # Concatenates the year with day of year of l_date_n
      l_date_c = str(l_date_n.year) + str(l_date_n.timetuple().tm_yday).zfill(3)

    if d_f == 'B':
      # Concatenates the year, month, and day of u_date_n
      u_date_c = str(u_date_n.year) + str(u_date_n.month).zfill(2) + str(u_date_n.day).zfill(2)
      # Concatenates the year, month, and day of l_date_n
      l_date_c = str(l_date_n.year) + str(l_date_n.month).zfill(2) + str(l_date_n.day).zfill(2)

    if date_p.year == year and (int(l_date_c) <= int(file_p) <= int(u_date_c)):
      # Constructs full path
      intput_raster = os.path.join(input_dir, f)
      # Concatenates the following variables
      # Has to by date index number, because the arcpy multipoint function has a name length limit
      data_name = product + "_" + str(i).zfill(3)
      print(file_p)
      print(data_name + " " + str(date_n))
      output_raster = data_name
      raster_points(input_raster, output_raster, gb_thirty_points)
      j = True
  i = i+1

"""- Arcpy can validate the use of the table name and can be used for geoprocessing operations.

- The *len(os.listdir(input_dir))* uses the input directory to retrieve the number of files in the directory and the list of files that were returned.

- Lastly, the value of the offset is printed.
"""

arcpy.ValidateTableName(gb_thirty_points)

len(os.listdir(input_dir))

print(offset)