# -*- coding: utf-8 -*-
"""auto_multipoint_extracter.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uyJCye6AGsN7KO997T4A7MiJjNSetCJI

#Introduction
**Auto_multipoint_extracter**
---
The following libraries allow the program to run.
>* **arcpy** - Allows to run all train and test scripts in an interactive environment.
* **env** - Accesses and uses the arcpy library to define variables in the env module.
* **re** - regular expression or re-uses a set of strings or searches for a certain pattern.
* **Pandas** -  Used to model, analysis, and manipulate data sets
* **arcpy.sa import *** - from the arcpy.sa module the user can use the *arcpy.sa import* to use spatial analyst.
* **os** - Allows the directory service to provides the ability to create and remove directory folders, gather data, change and find the current directory, and provide a means for users and the operating system to interact with each other
"""

# Libraries
import arcpy
from arcpy import env
import re
import pandas as pd
from arcpy.sa import *
import os

"""If the *input_raster* exists, then the values are extracted from the input raster and are transferred to the shapefile which creates a new raster file due to the *ExtractMultiValesToPoints*."""

def raster_points(input_raster,output_raster,shp_file):
  # Read the input and check rasters
  in_raster = Raster(input_raster)
  ExtractMultiValuesToPoints(shp_file,[[in_raster,ouput_raster]],'NONE')
  #arcpy.sa.ExtractValuesToPoints(thrity_points, in_raster,thirty_points,'NONE')

# Define the parent folder and the geodatabase name
parent_folder = os.getcwd()
geodatabase_name = "example2.gdb"

# Create the file geodatabase
geodatabase_path = os.path.join(parent_folder,geodatabase_name)
if os.path.exists(geodatabase_path):
  print(geodatabase_path)
else:
  arcpy.CreateFileGDB_management(parent_folder,geodatabase_name)

# Set the geodatabase as the workspace
arcpy.env.workspace = geodatabase_path

# Set up the environment
arcpy.env.parallelProcessingFactor = 0
arcpy.CheckOutExtension("Spatial")
arcpy.env.matchMultidimensionalVariable = False
arcpy.env.overwriteOutput = True

"""Enter the product, input directory, and file path with name.

An example would be:
>*Enter the name of the data product:* **PPT**

>*Enter the input directory:* **E:\\share\\BIgRun\\Prism_PPT**

>*Enter the full file path and name of the grid shape file:* **E:\\share\\BIgRun\\Grids\\Grid_30.shp**

If the file does not exist then user will have to try again until told otherwise.
"""

# Set data product name
product = input("Enter the name of the data product: ")
# Set the input directory
input_dir = input("Enter the input directory: ")
# Set the file path and name of the grid shape file
grid_shape_file = input("Enter the full file path and name of the grid shape file: ")
while not os.path.exists(grid_shape_file):
  print('The shapefile was not found')
  co = input("Please try again: ")

"""The user is prompted to provide the information about the file they intend to work on. The filepath and the name of the template point shapefile are combined to create a file.

An example would be:
  - Gathering data for point shape file:
    > *Enter the full path of the template point shape file:* **E:\\\share\ArcGIS Projects\\\US_Soils\\\US_Soils.gdb**

    > *Enter the name of the template point shape file:* **Grid_30_Prime_label**

    > *Enter the name of the point shape file:* **PPT_30_Points.shp**

    > *Enter 'Y' if you are adding to an existing point shape file. If the user is creating or overwriting a new point file enter 'N':* **Y**


  - Output from the given data:
    > *Point shape name:* **PPT_30_Points.shp**

    > *File used:* **C:\\\Users\\\user_name\\\Documents\\\example2.gdb\\\PPT_30_Points.shp**


When the user inputs 'Y' to add to an existing point shape file, the point shape name is displayed. Subsequently, a file is created by combining the template point shapefile and the name of the template point shapefile. Conversely, if the user enters 'N', the variable *temp_point_shape_file* is utilized to create a file using *geodatabase_path* and *point_shape_name*.
"""

# Data needed for point shape file

temp_point_shape_path = input("Enter the full file path of the template point shape file: ")
temp_point_shape_name = input("Enter the name of the template point shape file: ")
temp_point_shape_file = os.path.join(temp_point_shape_path,temp_point_shape_name)

point_shape_name = input("Enter the name of the point shape file: ")
point_check = input("Enter 'Y' if you are adding to an existing point shape file. If you are creating or overwriting a new point file enter 'N': ")

print(point_shape_name)

while not point_check != 'Y' and point_check != 'N':
point_shape_file = input("Please try again: ")

if point_check =='Y':
 while not os.path.isfile(point_shape_file):
 print('The shapefile was not found, should be in the same directory as the .py script')
 point_shape_file = input("Please try again: ")

thirty_points = temp_point_shape_file
gb_thirty_points = os.path.join(geodatabase_path, point_shape_name)
print(gb_thirty_points)

if point_check == 'N':
  arcpy.conversion.FeatureClassToFeatureClass(thirty_points, geodatabase_path, point_shape_name)

"""The data from the file "dates.txt" will be read and parsed into a list of dates. Subsequently, the user will be prompted to input two values: monthly lag and offset. These values will be set to integers. Additionally, the user will specify the index from which the list of dates should be sliced. The code will then update the list by extracting the elements from the specified starting index to the end of the list.

An example would be:
> *Enter the number monthly lab:* **0**

> *Enter the day offset:* **0**

> *If you need to start on a different date enter its index, if not enter 1:* **1**
"""

# Read the list of dates
while not os.path.exists("dates.txt"):
  print('The date list txt was not found, should be in the same directory as the .py script. ')
  n = input("Press enter to try again: ")
text_file = open("dates.txt")
date = text_file.read().split(',')

lag = input("Enter the number monthly lag: ")
lag = int(lag)

offset = input("Enter the day offset: ")
offset = int(offset)

start = input("If you need to start on a different date enter it's index, if not enter 1: ")
start = int(start) - 1

date = date[start:]

"""The file extension is responsible for indicating the file's layout and structure. Similarly, the filename separator serves as a component of the file's title, enhancing its readability for users. *Furthermore, the user is prompted to specify the position of the date and the specific dates that should be processed.

An example would be:
> *Enter the file extension:* **.bil**

> *Enter the filename separator:* **_**

> *Enter the position of the date within the filenames, starting at index 0 (i.e., ALB_2000123 position is 1):* **4**

> *Enter the year you wish to process (to process all, leave blank and press enter):*

> *If the file uses %Y%j, type 'A'. Else if the file uses %Y%m%d, type 'B' :* **B**
"""

# File type
fytpe = input("Enter the file extension: ")

# Filename separator
sep = input("Enter the filename separator: ")

# Date Position
d_pos = input('Enter the position of the date within the filenames, starting at index 0 (example ALB_2000123 position is 1): ')
d_pos = int(d_pos)

# Year batch
yer = input("Enter the year you wish to process (to process all leave blank and press enter): ")

# Date Formatting
d_f = input("If the file uses %Y%j, type 'A'. Else if the file uses %Y%m%d, type 'B': ")
while d_f != 'A' and d_f != 'B':
  d = input("Input ERROR. If the file uses %Y%j, type 'A'. Else if the file uses %Y%m%d, type 'B': ")

if d_f == 'A':
  d_format = %Y%j
if d_f == 'B':
  d_format = %Y%m%d

"""Using the *input_dir* and *ftype* variables, the code can create a list of files and filter each list. Then, the date is set and can perform calculations for each date in the list. Next, if a condition is true and met for each file in the filtered list, *ref_dir*, it will then perform some operations. The code will then add 1 to the variable *i* at the end of each iteration.

- The **fdir** command is utilized to compile a catalog of directories within a designated directory.

  Subsequently, an empty list is established under the **ref_dir** variable.

  The program proceeds to ascertain whether the current file, denoted as **fd**, concludes with the specified file extension, **ftype**.

  If the condition is met, the file with the specified extension is appended to the **ref_dir** list.
- The code enters a loop that iterates through each date in the **date** list. For each date in the list, the **j** variable is initialized to **False**.
  - The program first converts a date formatted as '*%m/%d/%Y* ' into a datetime object, then adds a specified number of months to the date.
  - The variable **date_n** provides the year, which is extracted from it. **u_date_n** is created by adding the specified number of days to **date_n**. **l_date_n** is created by subtracting the specified number of days from **date_n**.
"""

# Creates list
fdir = os.listdir(input_dir)
ref_dir = []
for fd in fdir:
  if fd.endswith(ftype):
    ref_dir.append(fd)
i = start

# Sets format for date
for d in date:
  j = False
  # Converts current date to datetime and adds specified number of months
  date_n = pd.to_datetime(d, format = "%m%d%Y") + pd.DateOffset(months = lag)
  # Extracts the year from date_n
  year = date_n.year
  # Adds specified days to date_n
  u_date_n = date_n + pd.DateOffset(days=offset)
  # Subtracts specified days from date_n
  l_date_n = date_n - pd.DateOffset(days=offset)
  for f in ref dir:
    if j == True:
      break
    # Splits f using the separator (sep)
    file_p = f.split(sep)
    # Replaces non-digit charac. with a "\"
    file_p = re.sub("D","\\",file_p[d_pos])
    # Converts to datetime
    date_p = pd.to_datetime(file_p, formate=d_format)

    if d_f == 'A':
      # Extracts day of year from date_n and stores in doy
      doy = date_n.timetuple().tm_yday
      # Concatenates the year with day of year of u_date_n
      u_date_c = str(u_date_n.year) + str(u_date_n.timetupe().tm_yday).zfill(3)
      # Concatenates the year with day of year of l_date_n
      l_date_c = str(l_date_n.year) + str(l_date_n.timetuple().tm_yday).zfill(3)

    if d_f == 'B':
      # Concatenates the year, month, and day of u_date_n
      u_date_c = str(u_date_n.year) + str(u_date_n.month).zfill(2) + str(u_date_n.day).zfill(2)
      # Concatenates the year, month, and day of l_date_n
      l_date_c = str(l_date_n.year) + str(l_date_n.month).zfill(2) + str(l_date_n.day).zfill(2)

    if date_p.year == year and (int(l_date_c) <= int(file_p) <= int(u_date_c)):
      # Constructs full path
      intput_raster = os.path.join(input_dir, f)
      # Concatenates the following variables
      # Has to by date index number, because th arcpy multipoint function has a name length limit
      data_name = product + "_" + str(i).zfill(3)
      print(file_p)
      print(data_name + " " + str(date_n))
      output_raster = data_name
      raster_points(input_raster, output_raster, gb_thirty_points)
      j = True
  i = i+1

"""Arcpy can validate the use of the table name and can be used for geoprocessing operations. The *len(os.listdir(input_dir))* uses the input directory to retrieve the number of files in the directory and the list of files that were returned. Lastly, the value of the offset is printed."""

arcpy.ValidateTableName(gb_thirty_points)

len(os.listdir(input_dir))

print(offset)